> # 45. General form of Optimization Verification test

 # 45. Dạng chung của thử nghiệm Xác minh Tối ưu hóa


> You can apply the Optimization Verification test when, given some input ​*x​*, you know how to compute Score​<sub>x</sub>​(*y​*) that indicates how good a response ​*y​* is to an input ​*x*.​ Furthermore, you are using an approximate algorithm to try to find arg max​<sub>y</sub>​ Score​<sub>x</sub>​(*y​*), but suspect that the search algorithm is sometimes failing to find the maximum. In our previous speech recognition example, ​*x=A​* was an audio clip, and ​*y=S​* was the output transcript.

Bạn có thể áp dụng thử nghiệm Xác minh tối ưu hóa khi, với một số đầu vào *x*, bạn biết cách tính Điểm <sub>x</sub> (*y*) dùng để thể hiện mức độ phản hồi *y* tốt như thế nào  với *x*. Hơn nữa, bạn đang sử dụng thuật toán gần đúng để cố gắng tìm arg max <sub>y</ sub> Điểm<sub>x</sub> (*y*), nhưng nghi ngờ rằng thuật toán tìm kiếm đôi khi không tìm thấy mức tối đa.  Trong ví dụ nhận dạng giọng nói trước đây của chúng tôi, *x=A* là một đoạn âm thanh và *y=S* là bản ghi đầu ra.


> Suppose y* is the "correct" output but the algorithm instead outputs y​<sub>out</sub>​. Then the key test is out​ to measure whether Score​<sub>x</sub>​(y*) > Score​<sub>x</sub>​(y​<sub>out</sub>). If this inequality holds, then we blame the out​ optimization algorithm for the mistake. Refer to the previous chapter to make sure you understand the logic behind this. Otherwise, we blame the computation of Score​<sub>x</sub>​(y).

Giả sử y* là đầu ra “chính xác” nhưng thuật toán thay vào đó đưa ra đầu ra y<sub>out</sub>.  Sau đó, bài kiểm tra chính được đưa ra để đo xem Điểm<sub>x</sub>(y*) > Điểm<sub>x</sub>(y<sub>out</sub>).  Nếu bất đẳng thức này giữ, thì chúng ta đổ lỗi cho thuật toán tối ưu hóa cho kết quả sai. Tham khảo chương trước để đảm bảo bạn hiểu logic đằng sau điều này.  Mặt khác, chúng tôi đổ lỗi cho tính toán của Điểm<sub>x </sub>(y).

> Let’s look at one more example. Suppose you are building a Chinese-to-English machine
> translation system. Your system works by inputting a Chinese sentence ​*C*,​ and computing
> some Score​<sub>C</sub>​(​*E*)​ for each possible translation ​E.​ For example, you might use Score​<sub>C</sub>​(​*E*)​ = P(*E*|*C*), the probability of the translation being E given that the input sentence was ​*C*.

Hãy để xem xét một ví dụ nữa.  Giả sử bạn đang xây dựng một máy dịch từ tiếng Trung sang tiếng Anh. Hệ thống của bạn hoạt động bằng cách nhập một câu tiếng Trung *C* và tính toán một số Điểm <sub>C</sub>(*E*) cho mỗi bản dịch có thể E. Ví dụ: bạn có thể sử dụng Điểm<sub>C</sub>(*E*) = P (*E*|*C*), xác suất dịch được E cho rằng câu đầu vào là *C*.

> Your algorithm translates sentences by trying to compute:

Thuật toán của bạn dịch các câu bằng cách cố gắng tính toán:

![img](../imgs/C45_01.png)

> However, the set of all possible English sentences ​*E* i​ s too large, so you rely on a heuristic search algorithm.

Tuy nhiên, tập hợp các câu tiếng Anh có thể *E* quá lớn nên bạn có thể dựa vào thuật toán tìm kiếm heuristic.

> Suppose your algorithm outputs an incorrect translation ​*E​*<sub>out</sub>​ rather than some correct translation ​E​*. Then the Optimization Verification test would ask you to compute whether Score​<sub>C</sub>​(*E**) > Score​<sub>C</sub>​(*E*<sub>out</sub>). If this inequality holds, then the Score​<sub>C</sub>​(.) correctly recognized E* as a superior output to *E​*<sub>out</sub>​; thus, you would attribute this error to the approximate search algorithm. Otherwise, you attribute this error to the computation of Score​<sub>C</sub>​(.).

Giả sử thuật toán của bạn dịch ra một bản không chính xác *E*<sub>out</sub> thay vì một số bản dịch chính xác E*.  Sau đó, bài kiểm tra Xác minh Tối ưu hóa sẽ yêu cầu bạn tính toán xem Điểm<sub>C</sub>(*E**)> Điểm<sub>C</sub>(*E*<sub>out</sub>) không. Nếu bất bình đẳng này giữ lại thì Điểm<sub>C</sub>(.) đã nhận dạng chính xác E* là đầu ra vượt trội hơn so với *E*<sub> out</sub>;  do đó, bạn sẽ gán lỗi này cho thuật toán tìm kiếm gần đúng.  Mặt khác, bạn gán lỗi này cho tính toán Điểm<sub>C</ sub> (.)

> It is a very common "design pattern" in AI to first learn an approximate scoring function
> Score​<sub>x</sub>​(.), then use an approximate maximization algorithm. If you are able to spot this pattern, you will be able to use the Optimization Verification test to understand your source of errors.

Đây là một “mẫu thiết kế” rất phổ biến trong AI để học hàm tính điểm gần đúng Điểm<sub>x</sub>(.), rồi sử dụng thuật toán tối đa hóa gần đúng.  Nếu bạn có thể phát hiện ra kiểu mẫu này, bạn sẽ có thể sử dụng thử nghiệm Xác minh Tối ưu hóa để hiểu nguồn lỗi của mình.
