> # 45. General form of Optimization Verification test

 # 45. Dạng chung của thử nghiệm Xác minh tối ưu


> You can apply the Optimization Verification test when, given some input ​*x​*, you know how to compute Score​<sub>\*</sub>​(*y​*) that indicates how good a response ​*y​* is to an input ​*x*.​ Furthermore, you are using an approximate algorithm to try to find arg max​<sub>y</sub>​ Score​<sub>\*</sub>​(*y​*), but suspect that the search algorithm is sometimes failing to find the maximum. In our previous speech recognition example, ​*x=A​* was an audio clip, and ​*y=S​* was the output transcript.

Bạn có thể áp dụng thử nghiệm Xác minh tối ưu khi, với một số đầu vào *x*, bạn biết cách tính Điểm<sub>\*</sub> (*y*) dùng để thể hiện mức độ phản hồi *y* tốt như thế nào với *x*. Hơn nữa, bạn đang sử dụng thuật toán gần đúng để cố gắng tìm arg max <sub>y</sub>Điểm<sub>\*</sub>(*y*), nhưng nghi ngờ rằng thuật toán tìm kiếm đôi khi không tìm thấy giá trị lớn nhất. Trong ví dụ nhận dạng giọng nói trước đây của chúng tôi, *x=A* là một đoạn âm thanh và *y=S* là bản ghi đầu ra.


> Suppose y\* is the "correct" output but the algorithm instead outputs y​<sub>out</sub>​. Then the key test is to measure whether Score​<sub>\*</sub>​(y*) > Score​<sub>\*</sub>​(y​<sub>out</sub>). If this inequality holds, then we blame the optimization algorithm for the mistake. Refer to the previous chapter to make sure you understand the logic behind this. Otherwise, we blame the computation of Score​<sub>\*</sub>​(y).

Giả sử y\* là đầu ra "chính xác" nhưng thuật toán thay vào đó tìm ra y<sub>out</sub>. Sau đó, bài kiểm tra chính là đo xem liệu Điểm<sub>\*</sub>(y\*) > Điểm<sub>\*</sub>(y<sub>out</sub>) hay không. Nếu bất đẳng thức này đúng, thì chúng ta đổ lỗi cho thuật toán tối ưu cho kết quả sai. Tham khảo chương trước để đảm bảo bạn hiểu logic đằng sau điều này. Ngược lại, chúng ta đổ lỗi cho cách tính Điểm<sub>\*</sub>(y).

> Let’s look at one more example. Suppose you are building a Chinese-to-English machine translation system. Your system works by inputting a Chinese sentence ​*C*,​ and computing some Score​<sub>C</sub>​(​*E*)​ for each possible translation ​E.​ For example, you might use Score​<sub>C</sub>​(​*E*)​ = P(*E*|*C*), the probability of the translation being E given that the input sentence was ​*C*.

Xem xét một ví dụ nữa. Giả sử bạn đang xây dựng một hệ thống dịch máy từ tiếng Trung sang tiếng Anh. Hệ thống của bạn hoạt động bằng cách nhập một câu tiếng Trung *C* và tính toán một gía trị Điểm<sub>C</sub>(*E*) cho mỗi bản dịch khả dĩ E. Ví dụ, bạn có thể sử dụng Điểm<sub>C</sub>(*E*) = P(*E*|*C*), xác suất dịch được E cho rằng câu đầu vào là *C*.

> Your algorithm translates sentences by trying to compute:

Thuật toán của bạn dịch các câu bằng cách cố gắng tính toán:

![img](../imgs/C45_01.png)

> However, the set of all possible English sentences *E* is too large, so you rely on a heuristic search algorithm.

Tuy nhiên, tập hợp các câu tiếng Anh có thể *E* quá lớn nên bạn dựa vào thuật toán tìm kiếm thực nghiệm.

> Suppose your algorithm outputs an incorrect translation ​*E​*<sub>out</sub>​ rather than some correct translation ​E​*. Then the Optimization Verification test would ask you to compute whether Score​<sub>C</sub>​(*E*\*) > Score​<sub>C</sub>​(*E*<sub>out</sub>). If this inequality holds, then the Score​<sub>C</sub>​(.) correctly recognized E\* as a superior output to *E​*<sub>out</sub>​; thus, you would attribute this error to the approximate search algorithm. Otherwise, you attribute this error to the computation of Score​<sub>C</sub>​(.).

Giả sử thuật toán của bạn dịch ra một bản không chính xác *E*<sub>out</sub> thay vì một số bản dịch chính xác E*. Sau đó, bài kiểm tra Xác minh tối ưu sẽ yêu cầu bạn tính toán xem liệu Điểm<sub>C</sub>(*E\**) > Điểm<sub>C</sub>(*E*<sub>out</sub>) không. Nếu bất bình đẳng này đúng thì Điểm<sub>C</sub>(.) đã nhận dạng chính xác E\* là đầu ra vượt trội hơn so với *E*<sub>out</sub>; do đó, bạn sẽ gán lỗi này cho thuật toán tìm kiếm gần đúng. Ngược lại, bạn gán lỗi này cho tính toán Điểm<sub>C</sub>(.)

> It is a very common "design pattern" in AI to first learn an approximate scoring function Score<sub>\*</sub>(.), then use an approximate maximization algorithm. If you are able to spot this pattern, you will be able to use the Optimization Verification test to understand your source of errors.

Đây là một “mẫu thiết kế” rất phổ biến trong AI khi học một hàm tính điểm gần đúng Điểm<sub>\*</sub>(.), sau đó sử dụng một thuật toán tối đa xấp xỉ. Nếu bạn có thể phát hiện ra kiểu mẫu này, bạn sẽ có thể sử dụng thử nghiệm Xác minh tối ưu để hiểu nguồn gốc lỗi của mình.
